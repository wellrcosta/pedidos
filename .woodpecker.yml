when:
  event: [push, manual]
  branch: [main]

variables:
  REGISTRY: ${REGISTRY=ghcr.io}
  IMAGE_REPO: ${IMAGE_REPO=${REGISTRY}/wellrcosta/${CI_REPO_NAME}}
  KUBE_NAMESPACE: ${KUBE_NAMESPACE=local-services}
  APP_NAME: ${APP_NAME=${CI_REPO_NAME}}
  MIN_COVERAGE: ${MIN_COVERAGE=60}

steps:
  install-and-test:
    name: Install & Test
    image: node:20
    commands:
      - corepack enable
      - |
        if [ -f pnpm-lock.yaml ]; then
          corepack prepare pnpm@latest --activate
          pnpm install --frozen-lockfile || pnpm install
          pnpm run test -- --coverage
        elif [ -f yarn.lock ]; then
          corepack prepare yarn@stable --activate
          yarn install --frozen-lockfile || yarn install
          yarn test --coverage
        elif [ -f package-lock.json ]; then
          npm ci
          npm run test -- --coverage
        else
          npm install
          npm run test -- --coverage
        fi
    when:
      branch: [ main ]
      event: [ push ]

  upload-coverage-codecov:
    name: Upload Coverage to Codecov
    image: alpine:latest
    environment:
      CODECOV_TOKEN:
        from_secret: CODECOV_TOKEN
    commands:
      - apk add --no-cache curl bash
      - curl -Os https://uploader.codecov.io/latest/linux/codecov
      - chmod +x codecov
      - ./codecov --token $CODECOV_TOKEN --fail-under=60 --file=coverage/lcov.info
    when:
      branch: [ main ]
      event: [ push ]
    image: alpine:3.20
    depends_on: [tests]
    commands:
      - |
        TOTAL=$(cat .coverage 2>/dev/null || echo 0)
        echo "Coverage: ${TOTAL}%"
        awk -v t="$TOTAL" -v m="${MIN_COVERAGE}" 'BEGIN{ if(t+0 < m) exit 1 }' || (echo "Coverage abaixo de ${MIN_COVERAGE}%"; exit 1)

  build_push:
    image: gcr.io/kaniko-project/executor:latest
    depends_on: [coverage_gate]
    environment:
      REGISTRY_USER:
        from_secret: REGISTRY_USER
      REGISTRY_TOKEN:
        from_secret: REGISTRY_TOKEN
    commands:
      - SHA=${CI_COMMIT_SHA}
      # auth GHCR
      - AUTH=$(printf "%s:%s" "$REGISTRY_USER" "$REGISTRY_TOKEN" | base64 -w 0 2>/dev/null || printf "%s:%s" "$REGISTRY_USER" "$REGISTRY_TOKEN" | base64)
      - |
        mkdir -p /kaniko/.docker
        cat > /kaniko/.docker/config.json <<EOF
        { "auths": { "${REGISTRY}": { "auth": "${AUTH}" } } }
        EOF
      - /kaniko/executor \
        --context "${CI_WORKSPACE}" \
        --dockerfile "${CI_WORKSPACE}/Dockerfile" \
        --destination "${IMAGE_REPO}:${SHA}" \
        --destination "${IMAGE_REPO}:latest"
      - echo "${SHA}" > .tag_sha

  bump_tag_commit:
    image: alpine:3.20
    depends_on: [build_push]
    environment:
      GITHUB_TOKEN:
        from_secret: GITHUB_TOKEN
    commands:
      - apk add --no-cache git yq
      - git config --global user.email "ci@wellrcosta.dev"
      - git config --global user.name "woodpecker-bot"
      - git remote set-url origin "https://wellrcosta:${GITHUB_TOKEN}@github.com/wellrcosta/${CI_REPO_NAME}.git"
      - SHA=$(cat .tag_sha)
      - |
        if [ -f deploy.values.yaml ]; then
          yq -i ".tag = \"${SHA}\"" deploy.values.yaml
          git add deploy.values.yaml
          git commit -m "chore(ci): update image tag to ${SHA}" || true
          git push origin HEAD:main
        else
          echo "deploy.values.yaml não encontrado; verifique se está na raiz."
          exit 1
        fi

  apply_secrets:
    image: bitnami/kubectl:1.30
    depends_on: [bump_tag_commit]
    environment:
      KUBE_CONFIG:
        from_secret: KUBE_CONFIG
      REGISTRY_USER:
        from_secret: REGISTRY_USER
      REGISTRY_TOKEN:
        from_secret: REGISTRY_TOKEN
    commands:
      - mkdir -p $HOME/.kube
      - echo "$KUBE_CONFIG" > $HOME/.kube/config
      - chmod 600 $HOME/.kube/config
      # imagePullSecret do GHCR
      - kubectl -n ${KUBE_NAMESPACE} create secret docker-registry registry-cred \
        --docker-server=${REGISTRY} --docker-username="${REGISTRY_USER}" --docker-password="${REGISTRY_TOKEN}" \
        --dry-run=client -o yaml | kubectl apply -f -
      # Secret com .env + espelho em env vars
      - |
        NAME=${APP_NAME}
        NS=${KUBE_NAMESPACE}
        TMP=/tmp/secret.yaml
        {
          echo "apiVersion: v1"
          echo "kind: Secret"
          echo "metadata:"
          echo "  name: ${NAME}-secrets"
          echo "  namespace: ${NS}"
          echo "type: Opaque"
          echo "stringData:"
          echo "  dotenv: |"
          env | awk -F= '/^ENV__/ {
            key=substr($1,6); val=$0; sub(/^[^=]*=/,"",val);
            printf "    %s=%s\n", key, val
          }'
          env | awk -F= '/^ENV__/ {
            key=substr($1,6); val=$0; sub(/^[^=]*=/,"",val);
            gsub(/\\/,"\\\\",val); gsub(/"/,"\\\"",val);
            printf "  \"%s\": \"%s\"\n", key, val
          }'
        } > $TMP
        kubectl apply -f $TMP
